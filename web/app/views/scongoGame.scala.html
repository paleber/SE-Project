@()
<link rel="import" href="@routes.Application.scongoFinish">
<link rel='import' href='@routes.Assets.at("bower_components/polymer/polymer.html")'>
<link rel='import' href='@routes.Assets.at("bower_components/paper-button/paper-button.html")'>

<dom-module id='scongo-game'>

    <template>

        <style>
                canvas {
                    background-color: lightgrey;

                    width: 100%;
                    display: block;
                    flex-grow: 1;
                }

                .hideCursor {
                    cursor: none;
                }
        </style>

        <div id="contentGame" style="display: none; flex-grow: 1; flex-direction: column;">
            <canvas id="can" width="800" height="500"></canvas>
        </div>
    </template>

    <script>
            Polymer({
                is: "scongo-game",

                properties: {
                    socketId: String,
                    socket: Object,

                    width: Number,
                    height: Number,
                    form: Number,
                    board: Object,
                    blocks: Object,

                    selIndex: Number,
                    selectedBlock: Object,

                    actionStartGrid: Object,
                    actionCounter: Number,
                    timer: Object,

                    lastMousePosX: Number,
                    lastMousePosY: Number
                },

                ready: function () {
                    this.socket = document.querySelector('#' + this.socketId);
                    window.addEventListener('keydown', this.keyDown, false);
                    window.addEventListener('resize', () => {document.querySelector("scongo-game").drawBoard()});
                },

                show: function(data) {
                    this.initGame(data.game);
                    $('#contentGame').css("display", "flex");
                },

                hide: function() {
                    $('#contentGame').css("display", "none");
                },

                levelClicked: function (e) {
                    this.socket.sendMsg("game " + e.target.getAttribute("level"));
                },

                initGame: function (level) {
                    this.height = level.height;
                    this.width = level.width;
                    this.form = level.form;
                    this.board = level.board;
                    this.blocks = level.blocks;
                    console.log("board size: " + this.width + " " + this.height);
                    console.log("board form: " + this.form);
                    console.log("board: " + JSON.stringify(this.board));
                    for (let i = 0; i < this.blocks.length; i++) {
                        console.log("board " + i + ": " + JSON.stringify(this.blocks[i]));
                    }

                    this.selIndex = -1;

                    let canvas = document.getElementById("can");
                    canvas.onmousedown = function (e) {
                        document.querySelector("scongo-game").selectBlock(e);
                    };

                    canvas.onmouseup = function () {
                        document.querySelector("scongo-game").releaseBlock();
                    };

                    canvas.onmouseout = function () {
                        document.querySelector("scongo-game").releaseBlock();
                    };

                    canvas.onmousemove = function (e) {
                        document.querySelector("scongo-game").moveBlock(e);
                    };

                    this.drawBoard();
                },

                updateBlock: function (data) {
                    this.blocks[data.index] = data.block;
                    this.drawBoard();
                },

                drawBoard: function () {
                    let canvas = document.getElementById("can");
                    let ctx = canvas.getContext("2d");

                    let board = $("#board");
                    canvas.height = board.height();
                    canvas.width = board.width();

                    let sf = Math.min(canvas.width / this.width, canvas.height / this.height);

                    let xOffset = (canvas.width - this.width * sf) / 2;
                    let yOffset = (canvas.height - this.height * sf) / 2;

                    // Clear the board
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Draw the board
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#5d5d5d';
                    ctx.fillStyle = '#969696';
                    this.drawPolygon(ctx, sf, this.board, 0, 0, xOffset, yOffset);

                    for (let i = 0; i < this.board.lines.length; i++) {
                        let x1 = Math.round(sf * this.board.lines[i].start.x + xOffset);
                        let y1 = Math.round(sf * this.board.lines[i].start.y + yOffset);
                        let x2 = Math.round(sf * this.board.lines[i].end.x + xOffset);
                        let y2 = Math.round(sf * this.board.lines[i].end.y + yOffset);
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.closePath();
                        ctx.stroke();
                    }

                    // Draw the blocks
                    ctx.strokeStyle = '#009d9d';
                    ctx.fillStyle = '#00ffff';

                    for (let i = 0; i < this.blocks.length; i++) {
                        if (i != this.selIndex) {
                            this.drawPolygon(ctx, sf,
                                    this.blocks[i].grid,
                                    this.blocks[i].position.x,
                                    this.blocks[i].position.y,
                                    xOffset,
                                    yOffset);
                        }
                    }

                    ctx.strokeStyle = '#007f00';
                    ctx.fillStyle = '#00ff00';

                    if (this.selIndex != -1) {
                        this.drawPolygon(ctx, sf,
                                this.selectedBlock.grid,
                                this.selectedBlock.position.x,
                                this.selectedBlock.position.y,
                                xOffset,
                                yOffset);
                    }
                },

                selectBlock: function (e) {
                    let canvas = document.getElementById("can");
                    let sf = Math.min(canvas.width / this.width, canvas.height / this.height);

                    let xOffset = (canvas.width - this.width * sf) / 2;
                    let yOffset = (canvas.height - this.height * sf) / 2;

                    let x = ((e.clientX - canvas.getBoundingClientRect().left - xOffset) / sf) ;
                    let y = ((e.clientY - canvas.getBoundingClientRect().top - yOffset) / sf) ;
                    console.log("canvas clicked at (" + x + "|" + y + ")");

                    for (let i = 0; i < this.blocks.length; i++) {
                        if (this.pointInsidePoly(this.blocks[i].grid.corners,
                                        x - this.blocks[i].position.x, y - this.blocks[i].position.y)) {
                            console.log("Select Block " + i);
                            this.selIndex = i;
                            this.selectedBlock = this.blocks[i];
                            this.lastMousePosX = x;
                            this.lastMousePosY = y;
                            $("#contentGame").addClass("hideCursor");
                            this.drawBoard();
                            console.log("Selected block: " + this.selIndex);
                        }
                    }
                },

                releaseBlock: function () {
                    if (this.selIndex != -1) {
                        if (this.timer != undefined) {
                            clearTimeout(this.timer);
                        }
                        this.blocks[this.selIndex] = this.selectedBlock;
                        this.socket.sendMsg(
                                "move " +
                                this.selIndex + " " +
                                this.selectedBlock.position.x + " " +
                                this.selectedBlock.position.y);
                        this.selIndex = -1;
                        $("#contentGame").removeClass("hideCursor");
                        this.drawBoard();
                    }

                },

                moveBlock: function (e) {
                    if (this.selIndex == -1) {
                        return;
                    }

                    let canvas = document.getElementById("can");
                    let sf = Math.min(canvas.width / this.width, canvas.height / this.height);
                    let xOffset = (canvas.width - this.width * sf) / 2;
                    let yOffset = (canvas.height - this.height * sf) / 2;

                    let x = (e.clientX - canvas.getBoundingClientRect().left - xOffset) / sf;
                    let y = (e.clientY - canvas.getBoundingClientRect().top - yOffset) / sf;

                    this.selectedBlock.position.x += x - this.lastMousePosX ;
                    this.selectedBlock.position.y += y - this.lastMousePosY;

                    this.lastMousePosX = x;
                    this.lastMousePosY = y;

                    this.drawBoard();
                },

                drawPolygon: function (ctx, sf, poly, xPos, yPos, xOffset, yOffset) {
                    ctx.beginPath();
                    let xStart = Math.round(sf * (poly.corners[0].x + xPos) + xOffset);
                    let yStart = Math.round(sf * (poly.corners[0].y + yPos) + yOffset);
                    ctx.moveTo(xStart, yStart);
                    for (let i = 1; i < poly.corners.length; i++) {
                        let x = Math.round(sf * (poly.corners[i].x + xPos) + xOffset);
                        let y = Math.round(sf * (poly.corners[i].y + yPos) + yOffset);
                        ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                },

                pointInsidePoly: function (poly, x, y) {
                    let c = false;
                    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
                        if (( ( poly[i].y > y ) != ( poly[j].y > y ) ) && ( x < ( poly[j].x - poly[i].x ) *
                                ( y - poly[i].y ) / ( poly[j].y - poly[i].y ) + poly[i].x )) {
                            c = !c;
                        }
                    }
                    return c;
                },

                keyDown: function (e) {
                    document.querySelector("scongo-game").handleKeyCode(e.keyCode);
                },

                handleKeyCode: function (code) {
                    if (this.selIndex == -1) {
                        return;
                    }
                    switch (code) {
                        case 65:
                        case 37:
                            // left - rotate
                            this.socket.sendMsg("left " + this.selIndex);
                            this.actionStartGrid = JSON.parse(JSON.stringify(this.selectedBlock.grid));
                            this.rotateLeft(1);
                            break;
                        case 68:
                        case 39:
                            // right - rotate
                            this.socket.sendMsg("right " + this.selIndex);
                            this.actionStartGrid = JSON.parse(JSON.stringify(this.selectedBlock.grid));
                            this.rotateRight(1);
                            break;
                        case 87:
                        case 38:
                            // up - mirror vertical axis
                            this.socket.sendMsg("vertical " + this.selIndex);
                            this.actionStartGrid = JSON.parse(JSON.stringify(this.selectedBlock.grid));
                            this.mirrorVertical(1);
                            break;
                        case 83:
                        case 40:
                            // down - mirror horizontal axis
                            this.socket.sendMsg("horizontal " + this.selIndex);
                            this.actionStartGrid = JSON.parse(JSON.stringify(this.selectedBlock.grid));
                            this.mirrorHorizontal(1);
                            break;
                        default:
                            return;
                    }
                },

                mirrorVertical: function (counter) {
                    let factor = 1 - 0.2 * counter;
                    for (let i = 0; i < this.actionStartGrid.corners.length; i++) {
                        this.selectedBlock.grid.corners[i].x = this.actionStartGrid.corners[i].x * factor;
                    }
                    this.drawBoard();
                    if (counter < 10) {
                        this.timer = setTimeout(this.timerEvent, 15, counter + 1, 'vertical');
                    }
                },

                mirrorHorizontal: function (counter) {
                    let factor = 1 - 0.2 * counter;
                    for (let i = 0; i < this.actionStartGrid.corners.length; i++) {
                        this.selectedBlock.grid.corners[i].y = this.actionStartGrid.corners[i].y * factor;
                    }
                    this.drawBoard();
                    if (counter < 10) {
                        this.timer = setTimeout(this.timerEvent, 15, counter + 1, 'horizontal');
                    }
                },

                rotateLeft: function (counter) {
                    let angle = -Math.PI * 2 / this.form / 10 * counter;
                    let sin = Math.sin(angle);
                    let cos = Math.cos(angle);
                    for (let i = 0; i < this.actionStartGrid.corners.length; i++) {
                        let x = this.actionStartGrid.corners[i].x;
                        let y = this.actionStartGrid.corners[i].y;
                        this.selectedBlock.grid.corners[i].x = x * cos - y * sin;
                        this.selectedBlock.grid.corners[i].y = x * sin + y * cos;
                    }
                    this.drawBoard();
                    if (counter < 10) {
                        this.timer = setTimeout(this.timerEvent, 15, counter + 1, 'left');
                    }
                },

                rotateRight: function (counter) {
                    let angle = Math.PI * 2 / this.form / 10 * counter;
                    let sin = Math.sin(angle);
                    let cos = Math.cos(angle);
                    for (let i = 0; i < this.actionStartGrid.corners.length; i++) {
                        let x = this.actionStartGrid.corners[i].x;
                        let y = this.actionStartGrid.corners[i].y;
                        this.selectedBlock.grid.corners[i].x = x * cos - y * sin;
                        this.selectedBlock.grid.corners[i].y = x * sin + y * cos;
                    }
                    this.drawBoard();
                    if (counter < 10) {
                        this.timer = setTimeout(this.timerEvent, 15, counter + 1, 'right');
                    }
                },

                timerEvent: function (counter, action) {
                    let scongo = document.querySelector("scongo-game");
                    switch (action) {
                        case 'vertical':
                            scongo.mirrorVertical(counter);
                            break;
                        case 'horizontal':
                            scongo.mirrorHorizontal(counter);
                            break;
                        case 'left':
                            scongo.rotateLeft(counter);
                            break;
                        case 'right':
                            scongo.rotateRight(counter);
                            break;
                        default:
                            return;
                    }
                }

            });
    </script>

</dom-module>
